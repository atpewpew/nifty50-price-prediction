"""
Feature Engineering for Price Direction Prediction

This module creates technical indicators and features from OHLCV data
to help predict whether the next candle's closing price will go up or down.

Features include:
- Momentum indicators (RSI, MACD)
- Volatility indicators (ATR, Bollinger Bands)
- Lag features for temporal context
- Cyclical time encoding
"""

import pandas as pd
import numpy as np
from src.indicators import calculate_rsi, calculate_macd, calculate_atr, calculate_bollinger_bands


def add_features(df):
    """
    Add technical analysis features to the dataframe.
    
    Args:
        df: DataFrame with OHLCV columns (open, high, low, close, volume)
    
    Returns:
        DataFrame with additional feature columns
    """
    df = df.copy()
    
    # --- 1. Momentum Indicators ---
    # RSI: Relative Strength Index (Overbought/Oversold signal)
    # RSI > 70 typically indicates overbought, < 30 indicates oversold
    df['rsi_14'] = calculate_rsi(df['close'], 14)
    
    # MACD: Moving Average Convergence Divergence (Trend Following)
    # When MACD crosses above signal line, it's bullish
    df['macd'], df['macd_signal'] = calculate_macd(df['close'])
    df['macd_diff'] = df['macd'] - df['macd_signal']
    
    # --- 2. Volatility Indicators ---
    # ATR: Average True Range (Market "Energy"/Volatility)
    df['atr_14'] = calculate_atr(df)
    
    # Bollinger Bands (Mean Reversion indicator)
    upper, lower = calculate_bollinger_bands(df['close'])
    df['bb_width'] = (upper - lower) / df['close']  # Normalized band width
    df['dist_from_upper'] = upper - df['close']      # Distance from upper band
    
    # --- 3. Lag Features (Temporal Context) ---
    # Log returns capture percentage changes
    df['log_ret'] = np.log(df['close'] / df['close'].shift(1))
    
    # What happened in recent candles? (1, 2, 3, 5, 10 periods ago)
    lags = [1, 2, 3, 5, 10]
    for lag in lags:
        df[f'log_ret_lag_{lag}'] = df['log_ret'].shift(lag)
        df[f'vol_lag_{lag}'] = df['volume'].shift(lag)

    # --- 4. Time Encoding (Cyclical) ---
    # Markets have daily patterns (e.g., opening/closing volatility)
    # We encode time cyclically using Sin/Cos (9:15 AM is not "smaller" than 3:30 PM)
    df['minute_of_day'] = df['timestamp'].dt.hour * 60 + df['timestamp'].dt.minute
    day_minutes = 24 * 60
    df['time_sin'] = np.sin(2 * np.pi * df['minute_of_day'] / day_minutes)
    df['time_cos'] = np.cos(2 * np.pi * df['minute_of_day'] / day_minutes)

    # Remove rows with NaN values generated by indicators
    df.dropna(inplace=True)
    
    return df


def create_target(df):
    """
    Create the target variable for prediction.
    
    Target: 1 if next candle's close > current close, else 0
    
    Args:
        df: DataFrame with 'close' column
    
    Returns:
        DataFrame with 'target' column added
    """
    df = df.copy()
    
    # Shift close price to get next candle's close
    df['next_close'] = df['close'].shift(-1)
    
    # Target: 1 if price goes up, 0 if price goes down
    df['target'] = (df['next_close'] > df['close']).astype(int)
    
    # Remove last row (no next_close available)
    df.dropna(subset=['next_close'], inplace=True)
    
    return df